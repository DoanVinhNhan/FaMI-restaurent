import os
from django.core.management.base import BaseCommand
from django.core.files import File
from menu.models import MenuItem

class Command(BaseCommand):
    help = 'Import images generated by Gemini Flash from specified directory'

    def handle(self, *args, **options):
        # Determine paths
        # Assuming fami_backend is the current wdr, and images are in ../menu_images_gemini_flash
        base_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
        # Need to go up from core/management/commands to project root
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
        # Actually, let's look relative to CWD if possible or absolute path derived from user context
        
        # Based on File Explorer step 595:
        # CWD: /Users/doanvinhnhan/Downloads/XYZ/Báo cáo CK
        # Images: menu_images_gemini_flash/*.png
        # Backend is: fami_backend
        
        # User confirmed images are in media/menu_items (conceptually 'menu/media')
        image_dir = os.path.abspath(os.path.join(os.getcwd(), 'media', 'menu_items'))
        
        import unicodedata

        if not os.path.exists(image_dir):
            self.stdout.write(self.style.ERROR(f"Directory not found: {image_dir}"))
            # Fallback for different CWD
            image_dir = os.path.abspath(os.path.join(base_dir, 'media', 'menu_items'))
            self.stdout.write(f"Trying alternative path: {image_dir}")
            if not os.path.exists(image_dir):
                 return

        # List all available files for debugging and matching
        available_files = os.listdir(image_dir)
        self.stdout.write(f"Scanned {len(available_files)} files in {image_dir}")
        
        # Normalize file names to NFC for consistent comparison
        normalized_files = {} # map normalized -> real name
        for f in available_files:
            norm = unicodedata.normalize('NFC', f)
            normalized_files[norm] = f

        items = MenuItem.objects.all()
        count = 0

        for item in items:
            clean_name = item.name.split('(')[0].strip()
            # Normalize item name slug
            slug_name = clean_name.replace(" ", "_").lower()
            expected_name = unicodedata.normalize('NFC', slug_name + ".png")
            
            # Match Logic
            found_filename = None
            
            # 1. Exact match
            if expected_name in normalized_files:
                found_filename = normalized_files[expected_name]
            
            # 2. Try with 'ly_' prefix (common mismatch for drinks)
            elif ("ly_" + expected_name) in normalized_files:
                found_filename = normalized_files["ly_" + expected_name]
                
            # 3. Try without 'ly_' if item has it (reverse case)
            elif expected_name.startswith("ly_") and expected_name[3:] in normalized_files:
                found_filename = normalized_files[expected_name[3:]]
                
            # 4. Fuzzy / Contains
            else:
                 # Check if any file contains the main slug
                 for norm_f, real_f in normalized_files.items():
                     if slug_name in norm_f:
                         found_filename = real_f
                         break

            if found_filename:
                # User wants to LINK existing images, not create new copies.
                # Django ImageField stores the path relative to MEDIA_ROOT.
                # Since files are in media/menu_items, we set path to 'menu_items/filename'
                
                relative_path = os.path.join('menu_items', found_filename)
                
                # Check if this link is already set to avoid useless updates
                if item.image.name != relative_path:
                    item.image.name = relative_path
                    item.save()
                    count += 1
                    self.stdout.write(self.style.SUCCESS(f"Linked {item.name} -> {relative_path}"))
                else:
                    self.stdout.write(f"Already linked: {item.name}")

            else:
                self.stdout.write(self.style.WARNING(f"Image not found for {item.name}"))

        self.stdout.write(self.style.SUCCESS(f"Successfully linked {count} images."))
